#pragma once

#include <iostream>
#include <memory>
#include <vector>

#include "Definitions.hpp"
#include "DistanceFunctors.hpp"

/**
 * @brief Wrapper class around std::vector<value_t> that helps manipulate the vector as if it were a 2D nested vector.
 *        Keeping the data as a 1D vector rather than a nested vector makes it easier to implement with MPI.
 */
class Matrix
{
private:
    // Member variables
    std::vector<value_t> mData;
    int_fast32_t mNumRows;  // this is the number of datapoints in the matrix
    int_fast32_t mNumCols;  // this is the number of features of each datapoint in the matrix

public:
    Matrix() {}

    Matrix(const int_fast32_t& numRows, const int_fast32_t& numCols)
    {
        mData.reserve(numRows * numCols);
        mNumRows = numRows;
        mNumCols = numCols;
    }

    Matrix(std::vector<value_t> data, const int_fast32_t& numRows, const int_fast32_t& numCols)
    {
        if (data.size() > numRows * numCols)
        {
            throw std::runtime_error("The vector has more data than was specified.");
        }
        mData = data;
        mData.reserve(numRows * numCols);
        mNumRows = numRows;
        mNumCols = numCols;
    }

    /**
     * @brief Destroy the Matrix object
     */
    ~Matrix(){};

    /**
     * @brief Function to access the beginning of a "row" of the matrix, where each row of the matrix is a datapoint.
     *        This function returns an iterator to the beginning of the row which can be used to access the rest of the
     *        row.
     *
     * @param row - The number of the row to retrieve.
     * @return value_t *
     */
    value_t* at(const int_fast32_t& row) { return mData.data() + (row * mNumCols); }

    /**
     * @brief Function to access a specific value in the matrix.
     *
     * @param row - The row number that the value is in.
     * @param col - The column number that the value is in.
     * @return value_t&
     */
    value_t& at(const int_fast32_t& row, const int_fast32_t& col) { return *(this->at(row) + col); }

    const value_t at(const int_fast32_t& row, const int_fast32_t& col) const { return *(this->at(row) + col); }

    const value_t* at(const int_fast32_t& row) const { return mData.data() + (row * mNumCols); }

    void appendDataPoint(const value_t* datapoint)
    {
        if (getNumData() < mNumRows)
        {
            std::copy(datapoint, datapoint + mNumCols, std::back_inserter(mData));
        }
        else
        {
            throw std::overflow_error("Cannot append to full matrix");
        }
    }

    void fill(const int_fast32_t& val) { std::fill(mData.begin(), mData.end(), val); }

    void resize(const int_fast32_t& val)
    {
        mData.resize(val * mNumCols);
        mNumRows = val;
    }

    void reserve(const int_fast32_t& val)
    {
        mData.resize(val * mNumCols);
        if (val > mNumRows)
            mNumRows = val;
    }

    value_t* data() { return mData.data(); }

    int_fast32_t size() const { return mData.size(); }
    int_fast32_t getNumData() const { return mData.size() / mNumCols; }
    int_fast32_t getMaxNumData() const { return mNumRows; }
    int_fast32_t getNumFeatures() const { return mNumCols; }

    void operator=(const Matrix& lhs)
    {
        mData    = std::move(lhs.mData);
        mNumRows = lhs.mNumRows;
        mNumCols = lhs.mNumCols;
    }

    void display()
    {
        for (const auto& val : mData)
        {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    }
};

/**
 * @brief Class to wrap the clustering data generated by Kmeans.
 */
struct ClusterData
{
    // Public member variables
    Matrix mClusters;                       // the cluster centers
    std::vector<int_fast32_t> mClustering;  // the cluster assignments of each datapoint
    std::vector<value_t> mClusterWeights;   // the sum of the weights of each datapoint assigned to a cluster

    /**
     * @brief Default constructor.
     */
    ClusterData(){};

    /**
     * @brief Construct a new ClusterData object.
     *
     * @param numData - The number of datapoints that are being clustered.
     * @param numFeatures - The number of features each datapoint has.
     * @param numClusters - The number of clusters that the data is being clustered into.
     */
    ClusterData(const int_fast32_t& numData, const int_fast32_t& numFeatures, const int_fast32_t& numClusters) :
        mClusters(numClusters, numFeatures)
    {
        mClustering     = std::vector<int_fast32_t>(numData, -1);
        mClusterWeights = std::vector<value_t>(numClusters, 0);
    }

    /**
     * @brief Destroy the ClusterData object
     */
    ~ClusterData(){};

    /**
     * @brief Overloaded assignment operator.
     *
     * @param lhs - An instance of ClusterData that is to be copied into the calling instance of ClusterData.
     */
    void operator=(const ClusterData& lhs)
    {
        mClusters       = lhs.mClusters;
        mClustering     = std::move(lhs.mClustering);
        mClusterWeights = std::move(lhs.mClusterWeights);
    }
};

struct KmeansData
{
    const int mRank;
    const int_fast32_t mTotalNumData;
    const std::vector<int_fast32_t> mLengths;
    const std::vector<int_fast32_t> mDisplacements;
    const int_fast32_t mDisplacement;

    const Matrix* const pData;
    const std::vector<value_t>* const pWeights;
    const std::shared_ptr<IDistanceFunctor> pDistanceFunc;

    // dynamic data that changes each repeat
    Matrix* pClusters;
    std::vector<int_fast32_t>* pClustering;
    std::vector<value_t>* pClusterWeights;
    std::vector<value_t>* pSqDistances;

    KmeansData(Matrix* data, std::vector<value_t>* weights, std::shared_ptr<IDistanceFunctor> distanceFunc,
               const int& rank, const int_fast32_t& totalNumData, std::vector<int_fast32_t> lengths,
               std::vector<int_fast32_t> displacements) :
        mRank(rank),
        mTotalNumData(totalNumData),
        mLengths(lengths),
        mDisplacements(displacements),
        mDisplacement(displacements.at(mRank)),
        pData(data),
        pWeights(weights),
        pDistanceFunc(distanceFunc){};

    void setClusterData(ClusterData* clusterData)
    {
        pClusters       = &clusterData->mClusters;
        pClustering     = &clusterData->mClustering;
        pClusterWeights = &clusterData->mClusterWeights;
    }

    void setSqDistances(std::vector<value_t>* sqDistances) { pSqDistances = sqDistances; }

    int_fast32_t& clusteringAt(const int_fast32_t& dataIdx) { return pClustering->at(mDisplacement + dataIdx); }
    value_t& sqDistancesAt(const int_fast32_t& dataIdx) { return pSqDistances->at(mDisplacement + dataIdx); }
    value_t& clusterWeightsAt(const int_fast32_t& clusterIdx) { return pClusterWeights->at(clusterIdx); }
};

/**
 * @brief A return structure that couples the distance between a point and its closest cluster and the index of that
 *        cluster together.
 */
struct ClosestCluster
{
    // Public member variables
    int_fast32_t clusterIdx;
    value_t distance;
};

struct ClusterResults
{
    value_t mError;
    ClusterData mClusterData;
    std::vector<value_t> mSqDistances;

    ClusterResults() : mError(-1) {}

    ~ClusterResults() {}
};

struct Coreset
{
    Matrix data;
    std::vector<value_t> weights;
};

struct MPIData
{
    int rank;
    int numProcs;
    std::vector<int_fast32_t> lengths;
    std::vector<int_fast32_t> displacements;
};