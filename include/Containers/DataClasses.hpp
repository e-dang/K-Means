#pragma once

#include <memory>

#include "Containers/Matrix.hpp"
#include "Utils/DistanceFunctors.hpp"

namespace HPKmeans
{
/**
 * @brief Class to wrap the clustering data generated by Kmeans.
 */
template <typename precision = double, typename int_size = int32_t>
struct ClusterData
{
    Matrix<precision, int_size> clusters;   // the cluster centers
    std::vector<int_size> clustering;       // the cluster assignments of each datapoint
    std::vector<precision> clusterWeights;  // the sum of the weights of each datapoint assigned to a cluster

    ClusterData() noexcept {}

    /**
     * @brief Construct a new ClusterData object.
     *
     * @param numData - The number of datapoints that are being clustered.
     * @param numFeatures - The number of features each datapoint has.
     * @param numClusters - The number of clusters that the data is being clustered into.
     */
    ClusterData(const int_size& numData, const int_size& numFeatures, const int_size& numClusters) :
        clusters(numClusters, numFeatures, false),
        clustering(std::vector<int_size>(numData, -1)),
        clusterWeights(std::vector<precision>(numClusters, 0.0))
    {
    }

    ClusterData(const ClusterData& other) noexcept :
        clusters(other.clusters), clustering(other.clustering), clusterWeights(clusterWeights)
    {
    }

    ClusterData(ClusterData&& other) noexcept : clusters(), clustering(), clusterWeights()
    {
        if (this != &other)
        {
            *this = std::move(other);
        }
    }

    ~ClusterData() = default;

    ClusterData& operator=(const ClusterData& lhs)
    {
        if (this != &lhs)
        {
            clusters       = lhs.clusters;
            clustering     = lhs.clustering;
            clusterWeights = lhs.clusterWeights;
        }

        return *this;
    }

    ClusterData& operator=(ClusterData&& lhs)
    {
        if (this != &lhs)
        {
            clusters       = std::move(lhs.clusters);
            clustering     = std::move(lhs.clustering);
            clusterWeights = std::move(lhs.clusterWeights);
        }

        return *this;
    }
};

template <typename precision = double, typename int_size = int32_t>
struct KmeansData
{
    const int rank;
    const int_size totalNumData;
    const std::vector<int_size> lengths;
    const std::vector<int_size> displacements;
    const int_size displacement;

    const Matrix<precision, int_size>* const data;
    const std::vector<precision>* const weights;
    const std::shared_ptr<IDistanceFunctor<precision>> distanceFunc;

    // dynamic data that changes each repeat
    Matrix<precision, int_size>* clusters;
    std::vector<int_size>* clustering;
    std::vector<precision>* clusterWeights;
    std::vector<precision>* sqDistances;

    KmeansData(const Matrix<precision, int_size>* const data, const std::vector<precision>* const weights,
               std::shared_ptr<IDistanceFunctor<precision>> distanceFunc, const int& rank, const int_size& totalNumData,
               const std::vector<int_size> lengths, const std::vector<int_size> displacements) noexcept :
        rank(rank),
        totalNumData(totalNumData),
        lengths(lengths),
        displacements(displacements),
        displacement(displacements.at(rank)),
        data(data),
        weights(weights),
        distanceFunc(distanceFunc)
    {
    }

    ~KmeansData() = default;

    void setClusterData(ClusterData<precision, int_size>* const clusterData)
    {
        clusters       = &clusterData->clusters;
        clustering     = &clusterData->clustering;
        clusterWeights = &clusterData->clusterWeights;
    }

    void setSqDistances(std::vector<precision>* const sqDistances) { this->sqDistances = sqDistances; }

    int_size& clusteringAt(const int_size& dataIdx) { return clustering->at(displacement + dataIdx); }
    precision& sqDistancesAt(const int_size& dataIdx) { return sqDistances->at(displacement + dataIdx); }
    precision& clusterWeightsAt(const int_size& clusterIdx) { return clusterWeights->at(clusterIdx); }
};

/**
 * @brief A return structure that couples the distance between a point and its closest cluster and the index of that
 *        cluster together.
 */
template <typename precision = double, typename int_size = int32_t>
struct ClosestCluster
{
    int_size clusterIdx;
    precision distance;
};

template <typename precision = double, typename int_size = int32_t>
struct ClusterResults
{
    precision error;
    ClusterData<precision, int_size> clusterData;
    std::vector<precision> sqDistances;

    ClusterResults() noexcept : error(-1.0) {}

    ClusterResults(ClusterResults&& other) noexcept : error(-1.0), clusterData(), sqDistances()
    {
        *this = std::move(other);
    }

    ~ClusterResults() = default;

    ClusterResults& operator=(ClusterResults&& rhs)
    {
        if (this != &rhs)
        {
            error       = rhs.error;
            clusterData = std::move(rhs.clusterData);
            sqDistances = std::move(rhs.sqDistances);
        }

        return *this;
    }
};

template <typename precision = double, typename int_size = int32_t>
struct Coreset
{
    Matrix<precision, int_size> data;
    std::vector<precision> weights;

    Coreset(const int_size& numData, const int_size& numFeatures, bool autoReserve = true) :
        data(numData, numFeatures, autoReserve)
    {
        weights.reserve(numData);
    }

    Coreset(Coreset&& other) : data(), weights() { *this = std::move(other); }

    ~Coreset() = default;

    Coreset& operator=(Coreset&& rhs)
    {
        if (this != &rhs)
        {
            data    = std::move(rhs.data);
            weights = std::move(rhs.weights);
        }

        return *this;
    }
};

template <typename int_size = int32_t>
struct MPIData
{
    int rank;
    int numProcs;
    std::vector<int_size> lengths;
    std::vector<int_size> displacements;

    MPIData(const int_size& rank, const int_size& numProcs, const std::vector<int_size>& lengths,
            const std::vector<int_size>& displacements) :
        rank(rank), numProcs(numProcs), lengths(lengths), displacements(displacements)
    {
    }

    ~MPIData() = default;

    MPIData(MPIData&& other) : rank(0), numProcs(0), lengths(), displacements() { *this = std::move(other); }

    MPIData& operator=(MPIData&& rhs)
    {
        if (this != &rhs)
        {
            rank          = rhs.rank;
            numProcs      = rhs.numProcs;
            lengths       = std::move(rhs.lengths);
            displacements = std::move(rhs.displacements);
        }

        return *this;
    }
};

enum Initializer
{
    InitNull = 0,
    KPP      = 1 << 0,
    OptKPP   = 1 << 1
};

enum Maximizer
{
    MaxNull  = 0,
    Lloyd    = 1 << 2,
    OptLloyd = 1 << 3
};

enum CoresetCreator
{
    None      = 0,
    LWCoreset = 1 << 4,
};

enum Parallelism
{
    ParaNull = 0,
    Serial   = 1 << 5,
    OMP      = 1 << 6,
    MPI      = 1 << 7,
    Hybrid   = 1 << 8
};

enum Variant
{
    Reg,
    Opt,
    SpecificCoreset
};
}  // namespace HPKmeans