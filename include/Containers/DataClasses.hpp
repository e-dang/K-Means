#pragma once

#include <memory>

#include "Containers/Matrix.hpp"
#include "Utils/DistanceFunctors.hpp"

namespace HPKmeans
{
/**
 * @brief Class to wrap the clustering data generated by Kmeans.
 */
template <typename precision, typename int_size>
struct ClusterData
{
    Matrix<precision, int_size> clusters;   // the cluster centers
    std::vector<int_size> clustering;       // the cluster assignments of each datapoint
    std::vector<precision> clusterWeights;  // the sum of the weights of each datapoint assigned to a cluster

    ClusterData() noexcept {}

    /**
     * @brief Construct a new ClusterData object.
     *
     * @param numData - The number of datapoints that are being clustered.
     * @param numFeatures - The number of features each datapoint has.
     * @param numClusters - The number of clusters that the data is being clustered into.
     */
    ClusterData(const int_size& numData, const int_size& numFeatures, const int_size& numClusters) :
        clusters(numClusters, numFeatures, false),
        clustering(std::vector<int_size>(numData, -1)),
        clusterWeights(std::vector<precision>(numClusters, 0.0))
    {
    }

    ClusterData(const ClusterData& other) noexcept :
        clusters(other.clusters), clustering(other.clustering), clusterWeights(clusterWeights)
    {
    }

    ClusterData(ClusterData&& other) noexcept : clusters(), clustering(), clusterWeights()
    {
        if (this != &other)
        {
            *this = std::move(other);
        }
    }

    ~ClusterData() = default;

    ClusterData& operator=(const ClusterData& lhs)
    {
        if (this != &lhs)
        {
            clusters       = lhs.clusters;
            clustering     = lhs.clustering;
            clusterWeights = lhs.clusterWeights;
        }

        return *this;
    }

    ClusterData& operator=(ClusterData&& lhs)
    {
        if (this != &lhs)
        {
            clusters       = std::move(lhs.clusters);
            clustering     = std::move(lhs.clustering);
            clusterWeights = std::move(lhs.clusterWeights);
        }

        return *this;
    }
};

template <typename precision, typename int_size>
struct ClusterResults
{
    precision error;
    ClusterData<precision, int_size> clusterData;
    std::vector<precision> sqDistances;

    ClusterResults() noexcept : error(-1.0) {}

    ClusterResults(ClusterResults&& other) noexcept : error(-1.0), clusterData(), sqDistances()
    {
        *this = std::move(other);
    }

    ~ClusterResults() = default;

    ClusterResults& operator=(ClusterResults&& rhs)
    {
        if (this != &rhs)
        {
            error       = rhs.error;
            clusterData = std::move(rhs.clusterData);
            sqDistances = std::move(rhs.sqDistances);
        }

        return *this;
    }
};

template <typename precision, typename int_size>
struct Coreset
{
    Matrix<precision, int_size> data;
    std::vector<precision> weights;

    Coreset(const int_size& numData, const int_size& numFeatures, bool autoReserve = true) :
        data(numData, numFeatures, autoReserve)
    {
        if (autoReserve)
        {
            weights = std::vector<precision>(numData);
        }
        else
        {
            weights.reserve(numData);
        }
    }

    Coreset(Coreset&& other) : data(), weights() { *this = std::move(other); }

    ~Coreset() = default;

    Coreset& operator=(Coreset&& rhs)
    {
        if (this != &rhs)
        {
            data    = std::move(rhs.data);
            weights = std::move(rhs.weights);
        }

        return *this;
    }
};

template <typename int_size>
struct MPIData
{
    int rank;
    int numProcs;
    std::vector<int_size> lengths;
    std::vector<int_size> displacements;

    MPIData(const int_size& rank, const int_size& numProcs, const std::vector<int_size>& lengths,
            const std::vector<int_size>& displacements) :
        rank(rank), numProcs(numProcs), lengths(lengths), displacements(displacements)
    {
    }

    ~MPIData() = default;

    MPIData(MPIData&& other) : rank(0), numProcs(0), lengths(), displacements() { *this = std::move(other); }

    MPIData& operator=(MPIData&& rhs)
    {
        if (this != &rhs)
        {
            rank          = rhs.rank;
            numProcs      = rhs.numProcs;
            lengths       = std::move(rhs.lengths);
            displacements = std::move(rhs.displacements);
        }

        return *this;
    }
};

enum Initializer
{
    InitNull = 0,
    KPP      = 1 << 0,
    OptKPP   = 1 << 1
};

enum Maximizer
{
    MaxNull  = 0,
    Lloyd    = 1 << 2,
    OptLloyd = 1 << 3
};

enum CoresetCreator
{
    None      = 0,
    LWCoreset = 1 << 4,
};

enum Parallelism
{
    ParaNull = 0,
    Serial   = 1 << 5,
    OMP      = 1 << 6,
    MPI      = 1 << 7,
    Hybrid   = 1 << 8
};

enum Variant
{
    Reg,
    Opt,
    SpecificCoreset
};
}  // namespace HPKmeans