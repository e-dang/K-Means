#pragma once

#include <memory>

#include "Containers/Matrix.hpp"
#include "Utils/DistanceFunctors.hpp"

namespace HPKmeans
{
/**
 * @brief Class to wrap the clustering data generated by Kmeans.
 */
template <typename precision, typename int_size>
struct ClusterData
{
    Matrix<precision, int_size> clusters;   // the cluster centers
    std::vector<int_size> clustering;       // the cluster assignments of each datapoint
    std::vector<precision> clusterWeights;  // the sum of the weights of each datapoint assigned to a cluster

    ClusterData() noexcept {}

    /**
     * @brief Construct a new ClusterData object.
     *
     * @param numData - The number of datapoints that are being clustered.
     * @param numFeatures - The number of features each datapoint has.
     * @param numClusters - The number of clusters that the data is being clustered into.
     */
    ClusterData(const int_size& numData, const int_size& numFeatures, const int_size& numClusters) :
        clusters(numClusters, numFeatures, false),
        clustering(std::vector<int_size>(numData, -1)),
        clusterWeights(std::vector<precision>(numClusters, 0.0))
    {
    }

    ClusterData(const ClusterData& other) noexcept :
        clusters(other.clusters), clustering(other.clustering), clusterWeights(clusterWeights)
    {
    }

    ClusterData(ClusterData&& other) noexcept : clusters(), clustering(), clusterWeights()
    {
        if (this != &other)
        {
            *this = std::move(other);
        }
    }

    ~ClusterData() = default;

    ClusterData& operator=(const ClusterData& lhs)
    {
        if (this != &lhs)
        {
            clusters       = lhs.clusters;
            clustering     = lhs.clustering;
            clusterWeights = lhs.clusterWeights;
        }

        return *this;
    }

    ClusterData& operator=(ClusterData&& lhs)
    {
        if (this != &lhs)
        {
            clusters       = std::move(lhs.clusters);
            clustering     = std::move(lhs.clustering);
            clusterWeights = std::move(lhs.clusterWeights);
        }

        return *this;
    }
};

template <typename precision, typename int_size>
struct KmeansData
{
    const int m_Rank;
    const int_size m_TotalNumData;
    const std::vector<int_size> m_Lengths;
    const std::vector<int_size> m_Displacements;
    const int_size m_Displacement;

    const Matrix<precision, int_size>* const p_Data;
    const std::vector<precision>* const p_Weights;
    const std::shared_ptr<IDistanceFunctor<precision>> p_DistanceFunc;

    // dynamic data that changes each repeat
    Matrix<precision, int_size>* p_Clusters;
    std::vector<int_size>* p_Clustering;
    std::vector<precision>* p_ClusterWeights;
    std::vector<precision>* p_SqDistances;

    KmeansData(const Matrix<precision, int_size>* const data, const std::vector<precision>* const weights,
               std::shared_ptr<IDistanceFunctor<precision>> distanceFunc, const int& rank, const int_size& totalNumData,
               const std::vector<int_size> lengths, const std::vector<int_size> displacements) noexcept :
        m_Rank(rank),
        m_TotalNumData(totalNumData),
        m_Lengths(lengths),
        m_Displacements(displacements),
        m_Displacement(displacements.at(rank)),
        p_Data(data),
        p_Weights(weights),
        p_DistanceFunc(distanceFunc)
    {
    }

    ~KmeansData() = default;

    inline precision operator()(const precision* point1, const precision* point2, const int32_t& numFeatures)
    {
        return (*p_DistanceFunc)(point1, point2, numFeatures);
    }

    void setClusterData(ClusterData<precision, int_size>* const clusterData)
    {
        p_Clusters       = &clusterData->clusters;
        p_Clustering     = &clusterData->clustering;
        p_ClusterWeights = &clusterData->clusterWeights;
    }

    inline void setSqDistances(std::vector<precision>* const sqDistances) { p_SqDistances = sqDistances; }

    inline const int_size totalNumData() noexcept { return m_TotalNumData; }

    inline const int rank() noexcept { return m_Rank; }

    inline const Matrix<precision, int_size>* data() const noexcept { return p_Data; }

    inline const precision* dataAt(const int_size& idx) const { return p_Data->at(idx); }

    inline const int_size dataSize() const noexcept { return p_Data->size(); }

    inline const std::vector<precision>* weights() const noexcept { return p_Weights; }

    inline const precision& weightsAt(const int_size& dataIdx) const { return p_Weights->at(dataIdx); }

    inline const int_size& myLength() const { return m_Lengths.at(m_Rank); }

    inline const std::vector<int_size>& lengths() const noexcept { return m_Lengths; }

    inline const int_size* lengthsData() const noexcept { return m_Lengths.data(); }

    inline const int_size& myDisplacement() const noexcept { return m_Displacement; }

    inline const int_size* displacementsData() const noexcept { return m_Displacements.data(); }

    inline const std::vector<int_size>* clustering() const noexcept { return p_Clustering; }

    inline int_size& clusteringAt(const int_size& dataIdx) { return p_Clustering->at(m_Displacement + dataIdx); }

    inline const int_size clusteringSize() const noexcept { return static_cast<int_size>(p_Clustering->size()); }

    inline int_size* clusteringData() noexcept { return p_Clustering->data(); }

    inline const std::vector<precision>* sqDistances() const noexcept { return p_SqDistances; }

    inline precision& sqDistancesAt(const int_size& dataIdx) { return p_SqDistances->at(m_Displacement + dataIdx); }

    inline precision* sqDistancesData() noexcept { return p_SqDistances->data(); }

    inline typename std::vector<precision>::iterator sqDistancesBegin() noexcept { return p_SqDistances->begin(); }

    inline typename std::vector<precision>::iterator sqDistancesEnd() noexcept { return p_SqDistances->end(); }

    inline const std::vector<precision>* clusterWeights() const noexcept { return p_ClusterWeights; }

    inline precision& clusterWeightsAt(const int_size& clusterIdx) { return p_ClusterWeights->at(clusterIdx); }

    inline const precision* clusterWeightsData() const noexcept { return p_ClusterWeights->data(); }

    inline Matrix<precision, int_size>* clusters() noexcept { return p_Clusters; }

    inline const int_size clustersRows() const noexcept { return p_Clusters->rows(); }

    inline const int_size clustersCols() const noexcept { return p_Clusters->cols(); }

    inline precision* clustersData() noexcept { return p_Clusters->data(); }

    inline void clustersPushBack(const precision* datapoint) { p_Clusters->push_back(datapoint); }

    inline void clustersFill(const precision& val) { p_Clusters->fill(val); }

    inline void clustersReserve(const int_size& space) { p_Clusters->reserve(space); }

    inline const int_size clustersSize() const noexcept { return p_Clusters->size(); }

    inline const int_size clustersElements() const noexcept { return p_Clusters->elements(); }

    inline const precision* clustersAt(const int_size& row) const { return p_Clusters->at(row); }
};

/**
 * @brief A return structure that couples the distance between a point and its closest cluster and the index of that
 *        cluster together.
 */
template <typename precision, typename int_size>
struct ClosestCluster
{
    int_size clusterIdx;
    precision distance;
};

template <typename precision, typename int_size>
struct ClusterResults
{
    precision error;
    ClusterData<precision, int_size> clusterData;
    std::vector<precision> sqDistances;

    ClusterResults() noexcept : error(-1.0) {}

    ClusterResults(ClusterResults&& other) noexcept : error(-1.0), clusterData(), sqDistances()
    {
        *this = std::move(other);
    }

    ~ClusterResults() = default;

    ClusterResults& operator=(ClusterResults&& rhs)
    {
        if (this != &rhs)
        {
            error       = rhs.error;
            clusterData = std::move(rhs.clusterData);
            sqDistances = std::move(rhs.sqDistances);
        }

        return *this;
    }
};

template <typename precision, typename int_size>
struct Coreset
{
    Matrix<precision, int_size> data;
    std::vector<precision> weights;

    Coreset(const int_size& numData, const int_size& numFeatures, bool autoReserve = true) :
        data(numData, numFeatures, autoReserve)
    {
        if (autoReserve)
        {
            weights = std::vector<precision>(numData);
        }
        else
        {
            weights.reserve(numData);
        }
    }

    Coreset(Coreset&& other) : data(), weights() { *this = std::move(other); }

    ~Coreset() = default;

    Coreset& operator=(Coreset&& rhs)
    {
        if (this != &rhs)
        {
            data    = std::move(rhs.data);
            weights = std::move(rhs.weights);
        }

        return *this;
    }
};

template <typename int_size>
struct MPIData
{
    int rank;
    int numProcs;
    std::vector<int_size> lengths;
    std::vector<int_size> displacements;

    MPIData(const int_size& rank, const int_size& numProcs, const std::vector<int_size>& lengths,
            const std::vector<int_size>& displacements) :
        rank(rank), numProcs(numProcs), lengths(lengths), displacements(displacements)
    {
    }

    ~MPIData() = default;

    MPIData(MPIData&& other) : rank(0), numProcs(0), lengths(), displacements() { *this = std::move(other); }

    MPIData& operator=(MPIData&& rhs)
    {
        if (this != &rhs)
        {
            rank          = rhs.rank;
            numProcs      = rhs.numProcs;
            lengths       = std::move(rhs.lengths);
            displacements = std::move(rhs.displacements);
        }

        return *this;
    }
};

enum Initializer
{
    InitNull = 0,
    KPP      = 1 << 0,
    OptKPP   = 1 << 1
};

enum Maximizer
{
    MaxNull  = 0,
    Lloyd    = 1 << 2,
    OptLloyd = 1 << 3
};

enum CoresetCreator
{
    None      = 0,
    LWCoreset = 1 << 4,
};

enum Parallelism
{
    ParaNull = 0,
    Serial   = 1 << 5,
    OMP      = 1 << 6,
    MPI      = 1 << 7,
    Hybrid   = 1 << 8
};

enum Variant
{
    Reg,
    Opt,
    SpecificCoreset
};
}  // namespace HPKmeans